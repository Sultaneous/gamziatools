#!/usr/bin/python

# New Python module by Karim Sultan October 2020

# Creates a ready to edit blank template utility script.

from gamzia.colours import Colours as C
import datetime
import os
import sys
argv=sys.argv
argc=len(argv)

DEF_FILE="template.py"

def main():
   if argc<=1:
      print(f"{C.clg}Syntax: {C.clc}newmodule.py {C.clm}[ModuleName]   {C.clr}# Do not include '.py' extension{C.coff}")
      exit()

   # Fix up for module name errantly having .py in it
   fixup=argv[1]
   if (fixup.endswith(".py")):
      fixup=argv[1][0:-3]

   # Establish module name / also class name, etc...
   modulename=fixup[0].upper()+fixup[1:]

   # Filename is the lowercase version of the module name
   filename=fixup.lower()+".py"

   print(f"{C.clg}Creating module {C.clm}{modulename}{C.clg} in file {C.cly}{filename}{C.off}...")

   # Prep output
   template=["#!/usr/bin/python\n",
   "\n",
   f"# {modulename} by Karim Sultan, {datetime.datetime.now():%B %Y}.\n",
   "\n",
   f"# TODO: Insert description of {modulename} here.\n",
   "\n",
   "# Uncomment extra modules as required\n",
   "from __future__ import annotations\n",
   "import signal\n",
   "import json\n",
   "import types\n",
   "import datetime\n",
   "import getopt\n",             
   "from gamzia.colours import Colours as C\n",
   "from gamzia.timer import Timer\n",
   "from gamzia.datastructures import Stack, Queue, BinaryTree, TRAVERSALS\n",
   "#from gamzia.accountmanager import AccountManager as AcctMgr\n",
   "#from gamzia.filedescriptor import FileDescriptor as FD\n",
   "#from gamzia.filedescriptor import FILEMODE, HASHTYPE\n",
   "#import hashlib\n",
   "#import socket\n",
   "#import select\n",
   "#import numpy\n",
   "import os\n",
   "import sys\n",
   "argv=sys.argv\n",
   "argc=len(argv)\n",
   "\n",
   "# App Info Constants\n",
   f"APP_NAME    = \"{modulename}\"\n",
   "APP_VERSION = 1.0\n",
   "APP_AUTHOR  = \"Karim Sultan\"\n",
   f"APP_DATE    = \"{datetime.datetime.now():%B %Y}\"\n",
   "APP_EMAIL   = \"karimsultan@hotmail.com\"\n",
   "APP_BLURB   = \"TODO: REPLACE ME\"\n",
   f"APP_SYNTAX  = f\"{{C.clg}}Syntax: {{C.cdg}}python {{C.clc}}{modulename} {{C.clm}}[options] {{C.cly}}<target>{{C.off}}\"\n",
   "\n",
   "# Settings defaults\n",
   "DEF_DEBUG     = False          # Sets debug mode on/off\n",
   "DEF_ENC       = \"utf-8\"        # Default text encoding type\n",
   "DEF_OVERWRITE = False          # Determines whether to overwrite existing data\n",
   "DEF_VERBOSE   = False          # T/F for extra detail\n",
   "DEF_LOGGING   = False          # Logs output to file\n",
   "DEF_LOGFILE   = \"klogs.log\"    # Default log file\n",
   "DEF_ACCOUNTDB = \"kaccounts.db\" # Default accounts database\n",
   "DEF_AUTH      = False          # Require login?\n",
   "DEF_OUTEXT    = \".txt\"       # Default output file extension\n",
   "\n",
   "# Global\n",
   "FLAG_KILL = False             # Used to trap Ctrl-C\n",
   "FLAG_LOGOPEN = False          # Monitor on log file status\n",
   "logfilehandle = None          # File handle to log file\n",
   "isLogging = False             # Set true to log all output to file\n",
   "isVerbose = False             # Set true to output details\n",
   "isDebug   = False             # Set true to enable debug statements\n",
   "\n",
   "#*************************************************************************\n",
   "# The configuration class houses parameter and initialization data\n",
   "# which configures the client.\n",
   "# NOTE: Private variables must be prefixed with \"_\".  toDictionary() relies\n",
   "# on this.\n",
   "# TODO: Add in your configuration properties in this class.\n",
   "class Config:\n",
   "   def __init__(self):\n",
   "      # These are the public properties\n",
   "      self.isverbose=DEF_VERBOSE\n",
   "      self.isoverwrite=DEF_OVERWRITE\n",
   "      self.islogging=DEF_LOGGING\n",
   "      self.logfile=DEF_LOGFILE\n",
   "      self.inputfile=\"\"\n",
   "      self.outputfile=\"\"\n",
   "\n",
   "      # Private members\n",
   "      self._auth=DEF_AUTH\n",
   "      self._DEBUG=DEF_DEBUG\n",
   "\n",
   "      # Uncomment if using account manager; remember to import it\n",
   "      #self._accountmanager=AccountManager(DEF_ACCOUNTDB)\n",
   "\n",
   "   # Uses reflection to create a dictionary of public atributes\n",
   "   # Skips any methods or functions or internals.\n",
   "   def toDictionary(self, showprivate=False):\n",
   "      d={}\n",
   "      s=dir(self)\n",
   "      i=0\n",
   "\n",
   "      while True:\n",
   "         if s[i].startswith(\"__\") and s[i].endswith(\"__\"):\n",
   "            # Attribute is an internal, remove\n",
   "            s.pop(i)\n",
   "         elif (s[i].startswith(\"_\") and not showprivate):\n",
   "            # Attribute is a private variable or method, remove\n",
   "            s.pop(i)\n",
   "         elif (isinstance(getattr(self, s[i]), types.MethodType) or\n",
   "               \"function\" in str(type(getattr(self, s[i])))):\n",
   "            # Attribute is a method/function, remove\n",
   "            s.pop(i)\n",
   "         else:\n",
   "            # Attribute is a value attribute, continue\n",
   "            i+=1\n",
   "         if (i>=len(s)):\n",
   "            break\n",
   "      for key in s:\n",
   "         d[key]=getattr(self, key)\n",
   "      return (d)\n",
   "\n",
   "   def toString(self, showprivate=False):\n",
   "      s=\"\"\n",
   "      d=self.toDictionary(showprivate)\n",
   "      for key, value in d.items():\n",
   "         s+=f\"{key}={value}\\n\"\n",
   "      return(s)\n",
   "\n",
   "   def toJson(self):\n",
   "      # Produces a \"clean\" JSON string. Just uses a dictionary.\n",
   "      # Method toDictionary() uses reflection  to create itself.\n",
   "      d=self.toDictionary()\n",
   "      return(json.dumps(d))\n",
   "\n",
   "   # This is a factory method so it must be static\n",
   "   # We use futures to put some constraints on method signature.\n",
   "   @staticmethod\n",
   "   def deserialize(data) -> Config():\n",
   "      # Use reflection to fill JSON instance, return Config object\n",
   "      x=Config()\n",
   "      d=json.loads(data)\n",
   "      for key,value in d.items():\n",
   "         if (hasattr(x, key)):\n",
   "            setattr(x, key, value)\n",
   "      return(x)\n",
   "\n",
   "#*************************************************************************\n",
   "\n",
   "#*************************************************************************\n",
   f"class {modulename}:\n",
   "\n",
   "   def __init__(self):\n",
   "      # TODO: Add public attributes here. Private attributes start with '__'.\n",
   f"      self.public_test=\"{modulename}\"\n",
   f"      self.__private_test=\"{filename}\"\n",  
   "      pass\n",
   "\n",
   "   # Uses reflection to create a dictionary of public atributes\n",
   "   # Skips any methods or functions or internals.\n",
   "   def toDictionary(self, showprivate=False):\n",
   "      d={}\n",
   "      s=dir(self)\n",
   "      i=0\n",
   "\n",
   "      while True:\n",
   "         if s[i].startswith(\"__\") and s[i].endswith(\"__\"):\n",
   "            # Attribute is an internal, remove\n",
   "            s.pop(i)\n",
   "         elif (s[i].startswith(\"_\") and not showprivate):\n",
   "            # Attribute is a private variable or method, remove\n",
   "            s.pop(i)\n",
   "         elif (isinstance(getattr(self, s[i]), types.MethodType) or\n",
   "            \"function\" in str(type(getattr(self, s[i])))):\n",
   "            # Attribute is a method/function, remove\n",
   "            s.pop(i)\n",
   "         else:\n",
   "            # Attribute is a value attribute, continue\n",
   "            i+=1\n",
   "         if (i>=len(s)):\n",
   "            break\n",
   "      for key in s:\n",
   "         d[key]=getattr(self, key)\n",
   "      return (d)\n",
   "\n",
   "   def toString(self, showprivate=False):\n",
   "      s=\"\"\n",
   "      d=self.toDictionary(showprivate)\n",
   "      for key, value in d.items():\n",
   "         s+=f\"{key}={value}\\n\"\n",
   "      return(s)\n",
   "\n",
   "   def toJson(self):\n",
   "      # Produces a \"clean\" JSON string. Just uses a dictionary.\n",
   "      # Method toDictionary() uses reflection  to create itself.\n",
   "      d=self.toDictionary()\n",
   "      return(json.dumps(d))\n",
   "\n",
   "   # This is a factory method so it must be static\n",
   "   # We use futures to put some constraints on method signature.\n",
   "   @staticmethod\n",
   f"   def fromJson(data) -> {modulename}():\n",
   f"      # Use reflection to fill JSON instance, return {modulename} object\n",
   f"      x={modulename}()\n",
   "      d=json.loads(data)\n",
   "      for key,value in d.items():\n",
   "         if (hasattr(x, key)):\n",
   "            setattr(x, key, value)\n",
   "      return(x)\n",
   "\n",
   "#*************************************************************************\n",
   "\n",
   "# Traps control C for a smooth exit\n",
   "def onSignal_kill(sig, frame):\n",
   "   global FLAG_KILL\n",
   "   FLAG_KILL=True\n",
   "   print (f\"{C.bdr}{C.cly}CTRL-C Detected!{C.off}\")\n",
   "\n",
   "   # This is critical to close resources and flush buffers\n",
   "   if FLAG_LOGOPEN:\n",
   "      logfilehandle.close()\n",
   "   print()\n",
   "   exit()\n",
   "\n",
   "# Outputs a message for a serious error, and terminates program\n",
   "# Use this for fatal errors only!\n",
   "def error(message):\n",
   "   if (not FLAG_KILL):\n",
   "      print(f\"{C.clr}An error has occurred!\");\n",
   "      print(f\"{C.clm}{message}{C.off}\")\n",
   "      print(flush=True)\n",
   "      try:\n",
   "         if (config.islogging):\n",
   "            log(message)\n",
   "         # Close any sockets, resources, etc... here\n",
   "      except Exception as e:\n",
   "            pass\n",
   "      finally:\n",
   "         exit()\n",
   "\n",
   "# Outputs a message to a log file.\n",
   "# Strips the ANSI colour codes out of the string to stop log clutter.\n",
   "# Caches file handle so that it is only opened once, and closed on exit.\n",
   "# Applies a header to new logging session (captured to same logfile).\n",
   "# Format of a log is:\n",
   "# [time since program start] message\n",
   "def log(message):\n",
   "   global FLAG_LOGOPEN, logfilehandle\n",
   "   if not FLAG_LOGOPEN:\n",
   "      logfilehandle=open(config.logfile, \"at+\")\n",
   "      FLAG_LOGOPEN=True\n",
   "      log.logtimer=Timer()\n",
   "      log.logtimer.start()\n",
   "      now=datetime.datetime.now()\n",
   "      header=f\"\\n******************************************************************************\\n\" \\\n",
   "             f\"FBOMB Log File for FSERVE {config.sid}@{config.host}:{config.port}\\n\" \\\n",
   "             f\"On: {now:%Y-%m-%d %H:%M}\\n\" \\\n",
   "             f\"******************************************************************************\\n\"\n",
   "      logfilehandle.write(f\"{header}\\n\")\n",
   "   logmsg=f\"[{log.logtimer.peek():.5f}] {C.cstrip(message)}\"\n",
   "   if (not logmsg.endswith(\"\\n\")):\n",
   "      logmsg=logmsg+\"\\n\"\n",
   "   logfilehandle.write(f\"{logmsg}\")\n",
   "   logfilehandle.flush()\n",
   "\n",
   "# \"Pips up\" to let you know something minor happened, doesn't impact\n",
   "# program flow. This method is intended for non-fatal errors, either\n",
   "# as notifications (green coloring) or as alerts (red syntax).\n",
   "def pip(message, isalert=False):\n",
   "   if isalert:\n",
   "      print(f\"{C.cly}{C.bdr}{message}{C.off}\")\n",
   "   else:\n",
   "      print(f\"{C.clg}{C.bdg}{message}{C.off}\")\n",
   "   try:\n",
   "      if (config.islogging):\n",
   "         log(message)\n",
   "   except Exception as e:\n",
   "      pass\n",
   "\n",
   "# Outputs a message to screen only if in verbose mode OR if show==true\n",
   "# IE: note() -> only shown if verbose mode enabled\n",
   "def note(message, show=False):\n",
   "   if (config.isverbose or show==True):\n",
   "      print(f\"{C.clc}{C.boff}{message}{C.off}\")\n",
   "   # Always write to logfile no matter if verbose or not\n",
   "   try:\n",
   "      if (config.islogging):\n",
   "         log(message)\n",
   "   except Exception as e:\n",
   "      pass\n",
   "\n",
   "# Just outputs a message regardless of verboseness\n",
   "# IE: notex() -> always shown\n",
   "def notex(message):\n",
   "   note(message, show=True)\n",
   "\n",
   "# Shows the info, blurb, syntax and options screen.\n",
   "# TODO: Document any added switches and options.\n",
   "def showHelp():\n",
   "   # This title line is now output by main() on all usage, so comment for now\n",
   "   #print (f\"{C.cly}{C.bdb}{APP_NAME}{C.boff} v{APP_VERSION} by {APP_AUTHOR} {APP_DATE} {APP_EMAIL}\")\n",
   "   print (f\"{APP_BLURB}\")\n",
   "   print ()\n",
   "   print (f\"{C.clg}{APP_SYNTAX}\");\n",
   "   print ()\n",
   "   print (f\"{C.clc}Where:\")\n",
   "   print (f\"{C.clg}-?, --help:      {C.clc}This help screen\")\n",
   "   print (f\"{C.clg}-l, --log:       {C.clc}Enables logging and specifies log file; use -l \"\" for default\")\n",
   "   print (f\"{C.clg}-v, --verbose:   {C.clc}Enable verbose mode\")\n",
   "   print (f\"{C.clg}    --version:   {C.clc}Reports program version number and exits\")\n",
   "   print (f\"{C.clg}-D, --DEBUG:     {C.clc}Sets Debug mode\")\n",
   "   print (f\"{C.clg}-o, --overwrite: {C.clc}Enables overwriting existing files on writes\")\n",
   "   print (f\"{C.clgy}Parameter values can be after '=' or a space (ie, -p 10000 or -p=10000)\")\n",
   "   print (f\"{C.coff}\")\n",
   "   exit()\n",
   "\n",
   "# Parses the command line and gets all options / switches.  These values should be stored in\n",
   "# the global configuration structure (class).\n",
   "# TODO: Customize switches and options.\n",
   "def parseCommandLine():\n",
   "   if argc<2:\n",
   "      showHelp()\n",
   "\n",
   "   # Single switch options are listed with a ':' suffix only if they expect a value.\n",
   "   # Extended options (--) must have a '=' suffix if value is expected\n",
   "   try:\n",
   "       opts, args =getopt.getopt(argv[1:],\n",
   "        \"?SDvl:o\",\n",
   "        [\"help\",\"version\",\"verbose\", \"DEBUG\", \"log=\"])\n",
   "   except getopt.GetoptError as e:\n",
   "      error(f\"Arguments error: ({e.opt})=>{e.msg}\")\n",
   "      showHelp()\n",
   "\n",
   "   # Process\n",
   "   for opt, arg in opts:\n",
   "      #This line is useful for option debugging:\n",
   "      #print(f\"OPT:{opt}  ARG:{arg}\")\n",
   "\n",
   "      if (opt in (\"-?\", \"--help\")):\n",
   "         showHelp()\n",
   "\n",
   "      # This option check must come before version check\n",
   "      # as '-v' is in version, and I'm sticking to the 'in' patern\n",
   "      # (it makes expansion easy)\n",
   "      elif (opt in(\"-v\", \"--verbose\")):\n",
   "         config.isverbose=True\n",
   "\n",
   "      # Debugging flag\n",
   "      elif (opt in (\"-D\", \"--DEBUG\")):\n",
   "         config._DEBUG=True\n",
   "\n",
   "      # Handle logging as either a switch or an argument\n",
   "      elif (opt in(\"-l\", \"--log\")):\n",
   "         config.islogging=True\n",
   "         if (not arg==\"\"):\n",
   "            config.logfile=arg\n",
   "         else:\n",
   "            config.logfile=DEF_LOGFILE\n",
   "\n",
   "      # If file already exists, allows replacement\n",
   "      elif (opt in(\"-o\", \"--overwrite\")):\n",
   "         config.isoverwrite=True\n",
   "\n",
   "      # Show version and then exit immediately\n",
   "      elif (opt in (\"--version\")):\n",
   "         print(f\"{C.clc}Version: {C.clg}{APP_VERSION}{C.off}\")\n",
   "         exit()\n",
   "\n",
   "      # Greetings are always welcome\n",
   "      elif (opt in (\"-S\")):\n",
   "         pip(f\"{C.bdr}{C.cly}Sultaneous sends Salutations.{C.off}\")\n",
   "         exit()\n",
   "\n",
   "   # Options handled, now handle the one or more args\n",
   "   fileargs=[]\n",
   "   for arg in args:\n",
   "      # TODO: Capture args, validate here or in main\n",
   "      fileargs.append(arg);\n",
   "\n",
   "   if len(fileargs)==0:\n",
   "      error(\"Please specify input 6502 binary file.\")\n",
   "\n",
   "   config.inputfile=fileargs[0]\n",
   "   if (len(fileargs)>1):\n",
   "      config.outputfile=fileargs[1]\n",
   "   else:\n",
   "      config.outputfile=config.inputfile.split('.')[0] + DEF_OUTEXT\n",
   "\n",
   "def main():\n",
   "   global config\n",
   "   config=Config()\n",
   "\n",
   "   parseCommandLine()\n",
   "\n",
   # Validate\n",
   "   if (not os.path.isfile(config.inputfile)):\n",
   "      error(f\"Input file does not exist: {C.cwh}{config.inputfile}\")\n",
   "   if (os.path.isfile(config.outputfile) and (not config.isoverwrite)):\n",
   "      error(f\"Output file already exists.  Try using -o: {C.cwh}{config.outputfile}\")\n",
   "\n",
   "   if (config._DEBUG):\n",
   "      notex (config.toString(showprivate=True))\n",
   "\n",
   "   #TODO: Implement main logic here.\n",
   "\n",
   f"   {modulename.lower()}={modulename}()\n",
   f"   print({modulename.lower()}.toString())\n",
   "   pass\n",
   "\n",
   "if __name__==\"__main__\":\n",
   "   main()\n",
   "\n"]

   # Abort if file exists
   if (os.path.isfile(filename)):
       print (f"{C.bdr}{C.clr}ABORTED! {C.cly}The file {C.cwh}{filename} {C.cly}already exists.{C.off}")
       exit()

   # Create template file
   with (open(filename, "w+")) as file:
       for line in template:
          file.write(line)
   
   print (f"{C.clg}{C.bdg}Done.{C.off}")
   
if __name__=="__main__":
   main()
